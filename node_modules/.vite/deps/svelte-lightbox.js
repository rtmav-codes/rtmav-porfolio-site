import "./chunk-6A2TAOKG.js";
import {
  fade
} from "./chunk-JR46FCXW.js";
import {
  writable
} from "./chunk-7SIBWDBT.js";
import "./chunk-M6MB33T7.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  prop_dev,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  subscribe,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-4NZVM4V3.js";

// node_modules/svelte-lightbox/dist/LightboxThumbnail.svelte
var file = "node_modules/svelte-lightbox/dist/LightboxThumbnail.svelte";
function add_css(target) {
  append_styles(target, "svelte-fkcut5", "div.svelte-fkcut5{position:static;cursor:zoom-in}.svelte-lightbox-thumbnail > *{max-width:100%;height:auto}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlnaHRib3hUaHVtYm5haWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQUtJLEdBQUEsY0FBQSxDQUFBLEFBQ0ksUUFBQSxDQUFBLE1BQWdCLENBQ2hCLE1BQUEsQ0FBQSxPQUFlLEFBQ25CLENBQUEsQUFDQSw4QkFBQSxBQUFBLENBQUEsQUFDSSxTQUFBLENBQUEsSUFBZSxDQUNmLE1BQUEsQ0FBQSxJQUFZLEFBQ2hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTGlnaHRib3hUaHVtYm5haWwuc3ZlbHRlIl19 */");
}
function create_fragment(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[0]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-lightbox-thumbnail", true);
      toggle_class(div, "svelte-fkcut5", true);
      add_location(div, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[3],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      1 && /*$$restProps*/
      ctx2[0]]));
      toggle_class(div, "svelte-lightbox-thumbnail", true);
      toggle_class(div, "svelte-fkcut5", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightboxThumbnail", slots, ["default"]);
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(1, $$scope = $$new_props.$$scope);
  };
  return [$$restProps, $$scope, slots, click_handler];
}
var LightboxThumbnail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightboxThumbnail",
      options,
      id: create_fragment.name
    });
  }
};
var LightboxThumbnail_default = LightboxThumbnail;

// node_modules/svelte-lightbox/dist/Modal/BodyChild.svelte
var file2 = "node_modules/svelte-lightbox/dist/Modal/BodyChild.svelte";
function create_fragment2(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 17, 0, 414);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[4](div);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      2 && /*$$restProps*/
      ctx2[1]]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      ctx[4](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = [];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BodyChild", slots, ["default"]);
  let targetElement;
  let child;
  const stackTarget = () => {
    child = document.createElement("div");
    document.body.appendChild(child);
    child.appendChild(targetElement);
  };
  const removeTarget = () => {
    if (typeof document !== "undefined") {
      document.body.removeChild(child);
    }
  };
  onMount(stackTarget);
  onDestroy(removeTarget);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      targetElement = $$value;
      $$invalidate(0, targetElement);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    targetElement,
    child,
    stackTarget,
    removeTarget
  });
  $$self.$inject_state = ($$new_props) => {
    if ("targetElement" in $$props)
      $$invalidate(0, targetElement = $$new_props.targetElement);
    if ("child" in $$props)
      child = $$new_props.child;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [targetElement, $$restProps, $$scope, slots, div_binding];
}
var BodyChild = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BodyChild",
      options,
      id: create_fragment2.name
    });
  }
};
var BodyChild_default = BodyChild;

// node_modules/svelte-lightbox/dist/Modal/LightboxHeader.svelte
var file3 = "node_modules/svelte-lightbox/dist/Modal/LightboxHeader.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1f6fn54", "div.svelte-lightbox-header.svelte-1f6fn54{width:auto;height:3rem;display:flex;justify-content:flex-end;align-items:center}div.svelte-lightbox-header.fullscreen.svelte-1f6fn54{position:fixed;z-index:5;top:0;left:0;right:0}button.svelte-1f6fn54{background:transparent;font-size:3rem;border:none;color:white}button.svelte-1f6fn54:hover{color:lightgray;cursor:pointer}button.svelte-1f6fn54:active{background-color:transparent}button.fullscreen.svelte-1f6fn54{filter:drop-shadow(0 0 5px black) drop-shadow(0 0 10px black)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlnaHRib3hIZWFkZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXdCSSxHQUFBLHVCQUFBLGVBQUEsQ0FBQSxBQUNJLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLElBQVksQ0FDWixPQUFBLENBQUEsSUFBYSxDQUNiLGVBQUEsQ0FBQSxRQUF5QixDQUN6QixXQUFBLENBQUEsTUFBbUIsQUFDdkIsQ0FBQSxBQUNBLEdBQUEsdUJBQUEsV0FBQSxlQUFBLENBQUEsQUFDQyxRQUFBLENBQUEsS0FBZSxDQUNmLE9BQUEsQ0FBQSxDQUFVLENBQ1YsR0FBQSxDQUFBLENBQU0sQ0FDTixJQUFBLENBQUEsQ0FBTyxDQUNQLEtBQUEsQ0FBQSxDQUFRLEFBQ1QsQ0FBQSxBQUNBLE1BQUEsZUFBQSxDQUFBLEFBQ0ksVUFBQSxDQUFBLFdBQXVCLENBQ3ZCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQ0FDWixLQUFBLENBQUEsS0FBWSxBQUNoQixDQUFBLEFBQ0EscUJBQUEsTUFBQSxBQUFBLENBQUEsQUFDSSxLQUFBLENBQUEsU0FBZ0IsQ0FDaEIsTUFBQSxDQUFBLE9BQWUsQUFDbkIsQ0FBQSxBQUNBLHFCQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0MsZ0JBQUEsQ0FBQSxXQUE2QixBQUM5QixDQUFBLEFBQ0EsTUFBQSxXQUFBLGVBQUEsQ0FBQSxBQUNDLE1BQUEsQ0FBQSxZQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxDQUFBLFlBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsS0FBQSxDQUE4RCxBQUMvRCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkxpZ2h0Ym94SGVhZGVyLnN2ZWx0ZSJdfQ== */");
}
function create_if_block(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  let button_levels = [
    /*closeButtonProps*/
    ctx[0]
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text("×");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      t = claim_text(button_nodes, "×");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(button, button_data);
      toggle_class(
        button,
        "fullscreen",
        /*imagePreset*/
        ctx[2] === "fullscreen"
      );
      toggle_class(button, "svelte-1f6fn54", true);
      add_location(button, file3, 17, 8, 548);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (button.autofocus)
        button.focus();
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[8],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(button, button_data = get_spread_update(button_levels, [dirty & /*closeButtonProps*/
      1 && /*closeButtonProps*/
      ctx2[0]]));
      toggle_class(
        button,
        "fullscreen",
        /*imagePreset*/
        ctx2[2] === "fullscreen"
      );
      toggle_class(button, "svelte-1f6fn54", true);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(17:4) {#if showCloseButton}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div;
  let mounted;
  let dispose;
  let if_block = (
    /*showCloseButton*/
    ctx[1] && create_if_block(ctx)
  );
  let div_levels = [
    { class: "svelte-lightbox-header" },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx[2] === "fullscreen"
      );
      toggle_class(div, "svelte-1f6fn54", true);
      add_location(div, file3, 15, 0, 412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block)
        if_block.m(div, null);
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          /*keydown_handler*/
          ctx[7],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*showCloseButton*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "svelte-lightbox-header" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx2[2] === "fullscreen"
      );
      toggle_class(div, "svelte-1f6fn54", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["closeButtonProps", "showCloseButton", "enableEscapeToClose", "imagePreset"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightboxHeader", slots, []);
  const dispatch = createEventDispatcher();
  let { closeButtonProps = {} } = $$props;
  let { showCloseButton } = $$props;
  let { enableEscapeToClose } = $$props;
  let { imagePreset } = $$props;
  const handleKey = (event) => {
    if (enableEscapeToClose && event.key === "Escape") {
      dispatch("close");
    }
  };
  $$self.$$.on_mount.push(function() {
    if (showCloseButton === void 0 && !("showCloseButton" in $$props || $$self.$$.bound[$$self.$$.props["showCloseButton"]])) {
      console.warn("<LightboxHeader> was created without expected prop 'showCloseButton'");
    }
    if (enableEscapeToClose === void 0 && !("enableEscapeToClose" in $$props || $$self.$$.bound[$$self.$$.props["enableEscapeToClose"]])) {
      console.warn("<LightboxHeader> was created without expected prop 'enableEscapeToClose'");
    }
    if (imagePreset === void 0 && !("imagePreset" in $$props || $$self.$$.bound[$$self.$$.props["imagePreset"]])) {
      console.warn("<LightboxHeader> was created without expected prop 'imagePreset'");
    }
  });
  const keydown_handler = (event) => handleKey(event);
  const click_handler = () => dispatch("close");
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("closeButtonProps" in $$new_props)
      $$invalidate(0, closeButtonProps = $$new_props.closeButtonProps);
    if ("showCloseButton" in $$new_props)
      $$invalidate(1, showCloseButton = $$new_props.showCloseButton);
    if ("enableEscapeToClose" in $$new_props)
      $$invalidate(6, enableEscapeToClose = $$new_props.enableEscapeToClose);
    if ("imagePreset" in $$new_props)
      $$invalidate(2, imagePreset = $$new_props.imagePreset);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    closeButtonProps,
    showCloseButton,
    enableEscapeToClose,
    imagePreset,
    handleKey
  });
  $$self.$inject_state = ($$new_props) => {
    if ("closeButtonProps" in $$props)
      $$invalidate(0, closeButtonProps = $$new_props.closeButtonProps);
    if ("showCloseButton" in $$props)
      $$invalidate(1, showCloseButton = $$new_props.showCloseButton);
    if ("enableEscapeToClose" in $$props)
      $$invalidate(6, enableEscapeToClose = $$new_props.enableEscapeToClose);
    if ("imagePreset" in $$props)
      $$invalidate(2, imagePreset = $$new_props.imagePreset);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    closeButtonProps,
    showCloseButton,
    imagePreset,
    dispatch,
    handleKey,
    $$restProps,
    enableEscapeToClose,
    keydown_handler,
    click_handler
  ];
}
var LightboxHeader = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        closeButtonProps: 0,
        showCloseButton: 1,
        enableEscapeToClose: 6,
        imagePreset: 2
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightboxHeader",
      options,
      id: create_fragment3.name
    });
  }
  get closeButtonProps() {
    throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeButtonProps(value) {
    throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showCloseButton() {
    throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showCloseButton(value) {
    throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableEscapeToClose() {
    throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableEscapeToClose(value) {
    throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imagePreset() {
    throw new Error("<LightboxHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<LightboxHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightboxHeader_default = LightboxHeader;

// node_modules/svelte-lightbox/dist/Modal/LightboxBody.svelte
var file4 = "node_modules/svelte-lightbox/dist/Modal/LightboxBody.svelte";
function add_css3(target) {
  append_styles(target, "svelte-7ckwh", "div.svelte-lightbox-body.svelte-7ckwh{position:relative;width:auto;height:auto;max-height:80vh}div.svelte-lightbox-body > *{max-width:100%;max-height:inherit;height:auto;width:auto;object-fit:contain}div.svelte-lightbox-body.scroll > *{max-height:100%}div.svelte-lightbox-body.expand > *{flex-grow:1}div.fullscreen.svelte-7ckwh{width:inherit;max-width:inherit;height:inherit;max-height:100%;display:flex;align-items:center;justify-content:center}div.scroll.svelte-7ckwh{overflow:scroll}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlnaHRib3hCb2R5LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFVSSxHQUFBLHFCQUFBLGFBQUEsQ0FBQSxBQUNGLFFBQUEsQ0FBQSxRQUFrQixDQUNaLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLElBQVksQ0FFWixVQUFBLENBQUEsSUFBZ0IsQUFDcEIsQ0FBQSxBQUNILDRCQUFBLEFBQUEsQ0FBQSxBQUNDLFNBQUEsQ0FBQSxJQUFlLENBQ2YsVUFBQSxDQUFBLE9BQW1CLENBQ25CLE1BQUEsQ0FBQSxJQUFZLENBQ1osS0FBQSxDQUFBLElBQVcsQ0FDWCxVQUFBLENBQUEsT0FBbUIsQUFDcEIsQ0FBQSxBQUNBLG1DQUFBLEFBQUEsQ0FBQSxBQUNDLFVBQUEsQ0FBQSxJQUFnQixBQUNqQixDQUFBLEFBQ0EsbUNBQUEsQUFBQSxDQUFBLEFBQ0MsU0FBQSxDQUFBLENBQVksQUFDYixDQUFBLEFBQ0csR0FBQSxXQUFBLGFBQUEsQ0FBQSxBQUNJLEtBQUEsQ0FBQSxPQUFjLENBQ2pCLFNBQUEsQ0FBQSxPQUFrQixDQUNmLE1BQUEsQ0FBQSxPQUFlLENBQ3JCLFVBQUEsQ0FBQSxJQUFnQixDQUNoQixPQUFBLENBQUEsSUFBYSxDQUNiLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixlQUFBLENBQUEsTUFBdUIsQUFDckIsQ0FBQSxBQUNBLEdBQUEsT0FBQSxhQUFBLENBQUEsQUFDRixRQUFBLENBQUEsTUFBZ0IsQUFDZCxDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkxpZ2h0Ym94Qm9keS5zdmVsdGUiXX0= */");
}
function create_fragment4(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-lightbox-body svelte-7ckwh");
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx[0] === "fullscreen"
      );
      toggle_class(
        div,
        "scroll",
        /*imagePreset*/
        ctx[0] === "scroll"
      );
      toggle_class(
        div,
        "expand",
        /*enableImageExpand*/
        ctx[1]
      );
      add_location(div, file4, 4, 0, 73);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*imagePreset*/
      1) {
        toggle_class(
          div,
          "fullscreen",
          /*imagePreset*/
          ctx2[0] === "fullscreen"
        );
      }
      if (!current || dirty & /*imagePreset*/
      1) {
        toggle_class(
          div,
          "scroll",
          /*imagePreset*/
          ctx2[0] === "scroll"
        );
      }
      if (!current || dirty & /*enableImageExpand*/
      2) {
        toggle_class(
          div,
          "expand",
          /*enableImageExpand*/
          ctx2[1]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightboxBody", slots, ["default"]);
  let { imagePreset } = $$props;
  let { enableImageExpand } = $$props;
  $$self.$$.on_mount.push(function() {
    if (imagePreset === void 0 && !("imagePreset" in $$props || $$self.$$.bound[$$self.$$.props["imagePreset"]])) {
      console.warn("<LightboxBody> was created without expected prop 'imagePreset'");
    }
    if (enableImageExpand === void 0 && !("enableImageExpand" in $$props || $$self.$$.bound[$$self.$$.props["enableImageExpand"]])) {
      console.warn("<LightboxBody> was created without expected prop 'enableImageExpand'");
    }
  });
  const writable_props = ["imagePreset", "enableImageExpand"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<LightboxBody> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("imagePreset" in $$props2)
      $$invalidate(0, imagePreset = $$props2.imagePreset);
    if ("enableImageExpand" in $$props2)
      $$invalidate(1, enableImageExpand = $$props2.enableImageExpand);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ imagePreset, enableImageExpand });
  $$self.$inject_state = ($$props2) => {
    if ("imagePreset" in $$props2)
      $$invalidate(0, imagePreset = $$props2.imagePreset);
    if ("enableImageExpand" in $$props2)
      $$invalidate(1, enableImageExpand = $$props2.enableImageExpand);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imagePreset, enableImageExpand, $$scope, slots];
}
var LightboxBody = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { imagePreset: 0, enableImageExpand: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightboxBody",
      options,
      id: create_fragment4.name
    });
  }
  get imagePreset() {
    throw new Error("<LightboxBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<LightboxBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableImageExpand() {
    throw new Error("<LightboxBody>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableImageExpand(value) {
    throw new Error("<LightboxBody>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightboxBody_default = LightboxBody;

// node_modules/svelte-lightbox/dist/i18n.js
var i18n = writable({
  generateLocalizedGalleryCounter: (activeImage, imageCount) => {
    return `Image ${activeImage + 1} of ${imageCount}`;
  }
});
var i18n_default = i18n;

// node_modules/svelte-lightbox/dist/Modal/LightboxFooter.svelte
var file5 = "node_modules/svelte-lightbox/dist/Modal/LightboxFooter.svelte";
function add_css4(target) {
  append_styles(target, "svelte-1tzytrq", "div.svelte-lightbox-footer.svelte-1tzytrq{width:100%;height:auto;color:white;text-align:left;position:absolute}div.svelte-lightbox-footer.fullscreen.svelte-1tzytrq{position:fixed;z-index:5;bottom:0;left:0;right:0;padding-left:1rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTGlnaHRib3hGb290ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTRCSSxHQUFBLHVCQUFBLGVBQUEsQ0FBQSxBQUNJLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLElBQVksQ0FDWixLQUFBLENBQUEsS0FBWSxDQUNaLFVBQUEsQ0FBQSxJQUFnQixDQUNoQixRQUFBLENBQUEsUUFBa0IsQUFDdEIsQ0FBQSxBQUNBLEdBQUEsdUJBQUEsV0FBQSxlQUFBLENBQUEsQUFDSSxRQUFBLENBQUEsS0FBZSxDQUNmLE9BQUEsQ0FBQSxDQUFVLENBQ1YsTUFBQSxDQUFBLENBQVMsQ0FDVCxJQUFBLENBQUEsQ0FBTyxDQUNQLEtBQUEsQ0FBQSxDQUFRLENBQ1IsWUFBQSxDQUFBLElBQWtCLEFBQ3RCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTGlnaHRib3hGb290ZXIuc3ZlbHRlIl19 */");
}
function create_if_block2(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*localizedGalleryCounter*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*localizedGalleryCounter*/
        ctx[4]
      );
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file5, 21, 8, 645);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*localizedGalleryCounter*/
      16)
        set_data_dev(
          t,
          /*localizedGalleryCounter*/
          ctx2[4]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(21:4) {#if gallery !== null}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div;
  let h2;
  let t0;
  let h5;
  let t1;
  let if_block = (
    /*gallery*/
    ctx[3] !== null && create_if_block2(ctx)
  );
  let div_levels = [
    { class: "svelte-lightbox-footer" },
    /*$$restProps*/
    ctx[5]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      h2 = element("h2");
      t0 = space();
      h5 = element("h5");
      t1 = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h2 = claim_element(div_nodes, "H2", {});
      var h2_nodes = children(h2);
      h2_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      h5 = claim_element(div_nodes, "H5", {});
      var h5_nodes = children(h5);
      h5_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file5, 14, 4, 526);
      add_location(h5, file5, 17, 4, 567);
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx[0] === "fullscreen"
      );
      toggle_class(div, "svelte-1tzytrq", true);
      add_location(div, file5, 13, 0, 420);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h2);
      h2.innerHTML = /*title*/
      ctx[1];
      append_hydration_dev(div, t0);
      append_hydration_dev(div, h5);
      h5.innerHTML = /*description*/
      ctx[2];
      append_hydration_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*title*/
      2)
        h2.innerHTML = /*title*/
        ctx2[1];
      ;
      if (dirty & /*description*/
      4)
        h5.innerHTML = /*description*/
        ctx2[2];
      ;
      if (
        /*gallery*/
        ctx2[3] !== null
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "svelte-lightbox-footer" },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx2[0] === "fullscreen"
      );
      toggle_class(div, "svelte-1tzytrq", true);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let localizedGalleryCounter;
  const omit_props_names = ["imagePreset", "title", "description", "gallery"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $i18n;
  validate_store(i18n_default, "i18n");
  component_subscribe($$self, i18n_default, ($$value) => $$invalidate(6, $i18n = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LightboxFooter", slots, []);
  let { imagePreset } = $$props;
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { gallery = null } = $$props;
  const generateLocalizedGalleryCounter = (i18n2, gallery2) => {
    if (gallery2 !== null) {
      return i18n2.generateLocalizedGalleryCounter(gallery2.activeImage, gallery2.imageCount);
    }
  };
  $$self.$$.on_mount.push(function() {
    if (imagePreset === void 0 && !("imagePreset" in $$props || $$self.$$.bound[$$self.$$.props["imagePreset"]])) {
      console.warn("<LightboxFooter> was created without expected prop 'imagePreset'");
    }
  });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("imagePreset" in $$new_props)
      $$invalidate(0, imagePreset = $$new_props.imagePreset);
    if ("title" in $$new_props)
      $$invalidate(1, title = $$new_props.title);
    if ("description" in $$new_props)
      $$invalidate(2, description = $$new_props.description);
    if ("gallery" in $$new_props)
      $$invalidate(3, gallery = $$new_props.gallery);
  };
  $$self.$capture_state = () => ({
    i18n: i18n_default,
    imagePreset,
    title,
    description,
    gallery,
    generateLocalizedGalleryCounter,
    localizedGalleryCounter,
    $i18n
  });
  $$self.$inject_state = ($$new_props) => {
    if ("imagePreset" in $$props)
      $$invalidate(0, imagePreset = $$new_props.imagePreset);
    if ("title" in $$props)
      $$invalidate(1, title = $$new_props.title);
    if ("description" in $$props)
      $$invalidate(2, description = $$new_props.description);
    if ("gallery" in $$props)
      $$invalidate(3, gallery = $$new_props.gallery);
    if ("localizedGalleryCounter" in $$props)
      $$invalidate(4, localizedGalleryCounter = $$new_props.localizedGalleryCounter);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$i18n, gallery*/
    72) {
      $:
        $$invalidate(4, localizedGalleryCounter = generateLocalizedGalleryCounter($i18n, gallery));
    }
  };
  return [
    imagePreset,
    title,
    description,
    gallery,
    localizedGalleryCounter,
    $$restProps,
    $i18n
  ];
}
var LightboxFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        imagePreset: 0,
        title: 1,
        description: 2,
        gallery: 3
      },
      add_css4
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LightboxFooter",
      options,
      id: create_fragment5.name
    });
  }
  get imagePreset() {
    throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get gallery() {
    throw new Error("<LightboxFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set gallery(value) {
    throw new Error("<LightboxFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LightboxFooter_default = LightboxFooter;

// node_modules/svelte-lightbox/dist/Modal/ModalCover.svelte
var file6 = "node_modules/svelte-lightbox/dist/Modal/ModalCover.svelte";
function add_css5(target) {
  append_styles(target, "svelte-ydm2rh", `div.svelte-lightbox-overlay.svelte-ydm2rh{position:fixed;z-index:1000000!important;background-color:rgba(43, 39, 45, 0.87);top:0;bottom:0;left:0;right:0;overflow:hidden;width:100%;height:100%;display:flex;align-items:center;justify-content:center}div.svelte-lightbox-overlay.svelte-ydm2rh::before{content:'';position:absolute;top:0;bottom:0;left:0;right:0;opacity:0;z-index:-1}div.svelte-lightbox-overlay.svelte-ydm2rh::after{content:"";clear:both;display:table}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWxDb3Zlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBU0ksR0FBQSx3QkFBQSxjQUFBLENBQUEsQUFDSSxRQUFBLENBQUEsS0FBZSxDQUNmLE9BQUEsQ0FBQSxPQUFBLFVBQTBCLENBQzFCLGdCQUFBLENBQUEsS0FBQSxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxJQUFBLENBQXdDLENBQ3hDLEdBQUEsQ0FBQSxDQUFNLENBQ04sTUFBQSxDQUFBLENBQVMsQ0FDVCxJQUFBLENBQUEsQ0FBTyxDQUNQLEtBQUEsQ0FBQSxDQUFRLENBQ1IsUUFBQSxDQUFBLE1BQWdCLENBQ2hCLEtBQUEsQ0FBQSxJQUFXLENBQ1gsTUFBQSxDQUFBLElBQVksQ0FDWixPQUFBLENBQUEsSUFBYSxDQUNiLFdBQUEsQ0FBQSxNQUFtQixDQUNuQixlQUFBLENBQUEsTUFBdUIsQUFDM0IsQ0FBQSxBQUNBLEdBQUEsc0NBQUEsUUFBQSxBQUFBLENBQUEsQUFDSSxPQUFBLENBQUEsRUFBVyxDQUNYLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixHQUFBLENBQUEsQ0FBTSxDQUFFLE1BQUEsQ0FBQSxDQUFTLENBQUUsSUFBQSxDQUFBLENBQU8sQ0FBRSxLQUFBLENBQUEsQ0FBUSxDQUNwQyxPQUFBLENBQUEsQ0FBVSxDQUNWLE9BQUEsQ0FBQSxFQUFXLEFBQ2YsQ0FBQSxBQUNBLEdBQUEsc0NBQUEsT0FBQSxBQUFBLENBQUEsQUFDSSxPQUFBLENBQUEsRUFBVyxDQUNYLEtBQUEsQ0FBQSxJQUFXLENBQ1gsT0FBQSxDQUFBLEtBQWMsQUFDbEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNb2RhbENvdmVyLnN2ZWx0ZSJdfQ== */`);
}
function create_fragment6(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let div_levels = [
    { class: "svelte-lightbox-overlay" },
    /*$$restProps*/
    ctx[1]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-ydm2rh", true);
      add_location(div, file6, 4, 0, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[4],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "svelte-lightbox-overlay" },
        dirty & /*$$restProps*/
        2 && /*$$restProps*/
        ctx[1]
      ]));
      toggle_class(div, "svelte-ydm2rh", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(div, fade, {
          duration: (
            /*transitionDuration*/
            ctx[0] * 2
          )
        });
        div_intro.start();
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(div, fade, {
        duration: (
          /*transitionDuration*/
          ctx[0] / 2
        )
      });
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  const omit_props_names = ["transitionDuration"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ModalCover", slots, ["default"]);
  let { transitionDuration } = $$props;
  $$self.$$.on_mount.push(function() {
    if (transitionDuration === void 0 && !("transitionDuration" in $$props || $$self.$$.bound[$$self.$$.props["transitionDuration"]])) {
      console.warn("<ModalCover> was created without expected prop 'transitionDuration'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transitionDuration" in $$new_props)
      $$invalidate(0, transitionDuration = $$new_props.transitionDuration);
    if ("$$scope" in $$new_props)
      $$invalidate(2, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ fade, transitionDuration });
  $$self.$inject_state = ($$new_props) => {
    if ("transitionDuration" in $$props)
      $$invalidate(0, transitionDuration = $$new_props.transitionDuration);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [transitionDuration, $$restProps, $$scope, slots, click_handler];
}
var ModalCover = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { transitionDuration: 0 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ModalCover",
      options,
      id: create_fragment6.name
    });
  }
  get transitionDuration() {
    throw new Error("<ModalCover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<ModalCover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ModalCover_default = ModalCover;

// node_modules/svelte-lightbox/dist/Modal/Modal.svelte
var file7 = "node_modules/svelte-lightbox/dist/Modal/Modal.svelte";
function add_css6(target) {
  append_styles(target, "svelte-179ewat", "div.svelte-lightbox-main.svelte-179ewat{position:relative;max-width:100%;max-height:100%;height:auto;width:auto;background-color:transparent}div.svelte-lightbox-main.fullscreen.svelte-179ewat{height:inherit;width:inherit;max-height:inherit;max-width:inherit}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQVdLLEdBQUEscUJBQUEsZUFBQSxDQUFBLEFBQ0ksUUFBQSxDQUFBLFFBQWtCLENBQ2xCLFNBQUEsQ0FBQSxJQUFlLENBQ2YsVUFBQSxDQUFBLElBQWdCLENBQ2hCLE1BQUEsQ0FBQSxJQUFZLENBQ1osS0FBQSxDQUFBLElBQVcsQ0FDWCxnQkFBQSxDQUFBLFdBQTZCLEFBQ2xDLENBQUEsQUFDQyxHQUFBLHFCQUFBLFdBQUEsZUFBQSxDQUFBLEFBQ0MsTUFBQSxDQUFBLE9BQWUsQ0FDZixLQUFBLENBQUEsT0FBYyxDQUNYLFVBQUEsQ0FBQSxPQUFtQixDQUNuQixTQUFBLENBQUEsT0FBa0IsQUFDdEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJNb2RhbC5zdmVsdGUiXX0= */");
}
function create_fragment7(ctx) {
  let div;
  let div_transition;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    { class: "svelte-lightbox-main" },
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx[1] === "fullscreen"
      );
      toggle_class(
        div,
        "scroll",
        /*imagePreset*/
        ctx[1] === "scroll"
      );
      toggle_class(div, "svelte-179ewat", true);
      add_location(div, file7, 5, 0, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { class: "svelte-lightbox-main" },
        dirty & /*$$restProps*/
        4 && /*$$restProps*/
        ctx[2]
      ]));
      toggle_class(
        div,
        "fullscreen",
        /*imagePreset*/
        ctx[1] === "fullscreen"
      );
      toggle_class(
        div,
        "scroll",
        /*imagePreset*/
        ctx[1] === "scroll"
      );
      toggle_class(div, "svelte-179ewat", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, fade, { duration: (
            /*transitionDuration*/
            ctx[0]
          ) }, true);
        div_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (!div_transition)
        div_transition = create_bidirectional_transition(div, fade, { duration: (
          /*transitionDuration*/
          ctx[0]
        ) }, false);
      div_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching && div_transition)
        div_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  const omit_props_names = ["transitionDuration", "imagePreset"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["default"]);
  let { transitionDuration } = $$props;
  let { imagePreset } = $$props;
  $$self.$$.on_mount.push(function() {
    if (transitionDuration === void 0 && !("transitionDuration" in $$props || $$self.$$.bound[$$self.$$.props["transitionDuration"]])) {
      console.warn("<Modal> was created without expected prop 'transitionDuration'");
    }
    if (imagePreset === void 0 && !("imagePreset" in $$props || $$self.$$.bound[$$self.$$.props["imagePreset"]])) {
      console.warn("<Modal> was created without expected prop 'imagePreset'");
    }
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("transitionDuration" in $$new_props)
      $$invalidate(0, transitionDuration = $$new_props.transitionDuration);
    if ("imagePreset" in $$new_props)
      $$invalidate(1, imagePreset = $$new_props.imagePreset);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ fade, transitionDuration, imagePreset });
  $$self.$inject_state = ($$new_props) => {
    if ("transitionDuration" in $$props)
      $$invalidate(0, transitionDuration = $$new_props.transitionDuration);
    if ("imagePreset" in $$props)
      $$invalidate(1, imagePreset = $$new_props.imagePreset);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [transitionDuration, imagePreset, $$restProps, $$scope, slots, click_handler];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { transitionDuration: 0, imagePreset: 1 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment7.name
    });
  }
  get transitionDuration() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imagePreset() {
    throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/svelte-lightbox/dist/Lightbox.svelte
var get_thumbnail_slot_changes = (dirty) => ({});
var get_thumbnail_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let thumbnail;
  let current;
  const thumbnail_spread_levels = [
    /*customization*/
    ctx[4]?.thumbnailProps || {}
  ];
  let thumbnail_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < thumbnail_spread_levels.length; i += 1) {
    thumbnail_props = assign(thumbnail_props, thumbnail_spread_levels[i]);
  }
  thumbnail = new LightboxThumbnail_default({ props: thumbnail_props, $$inline: true });
  thumbnail.$on(
    "click",
    /*toggle*/
    ctx[10]
  );
  const block = {
    c: function create() {
      create_component(thumbnail.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(thumbnail.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(thumbnail, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const thumbnail_changes = dirty & /*customization*/
      16 ? get_spread_update(thumbnail_spread_levels, [get_spread_object(
        /*customization*/
        ctx2[4]?.thumbnailProps || {}
      )]) : {};
      if (dirty & /*$$scope, $$slots*/
      540672) {
        thumbnail_changes.$$scope = { dirty, ctx: ctx2 };
      }
      thumbnail.$set(thumbnail_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumbnail.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumbnail.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(thumbnail, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(65:0) {#if $$slots.thumbnail || enableFallbackThumbnail}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(69:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current;
  const thumbnail_slot_template = (
    /*#slots*/
    ctx[18].thumbnail
  );
  const thumbnail_slot = create_slot(
    thumbnail_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    get_thumbnail_slot_context
  );
  const block = {
    c: function create() {
      if (thumbnail_slot)
        thumbnail_slot.c();
    },
    l: function claim(nodes) {
      if (thumbnail_slot)
        thumbnail_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (thumbnail_slot) {
        thumbnail_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (thumbnail_slot) {
        if (thumbnail_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            thumbnail_slot,
            thumbnail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              thumbnail_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              get_thumbnail_slot_changes
            ),
            get_thumbnail_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumbnail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumbnail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (thumbnail_slot)
        thumbnail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(67:2) {#if $$slots.thumbnail}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_2, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[14].thumbnail
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(66:1) <Thumbnail {...(customization?.thumbnailProps || {})} on:click={toggle}>",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let bodychild;
  let current;
  bodychild = new BodyChild_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(bodychild.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(bodychild.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(bodychild, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bodychild_changes = {};
      if (dirty & /*$$scope, transitionDuration, customization, imagePreset, title, description, enableImageExpand, showCloseButton, enableEscapeToClose*/
      525182) {
        bodychild_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodychild.$set(bodychild_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bodychild.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bodychild.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bodychild, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(75:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[18].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(82:4) <Body {imagePreset} {enableImageExpand}>",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let header;
  let t0;
  let body;
  let t1;
  let footer;
  let current;
  const header_spread_levels = [
    { imagePreset: (
      /*imagePreset*/
      ctx[3]
    ) },
    {
      showCloseButton: (
        /*showCloseButton*/
        ctx[9]
      )
    },
    {
      enableEscapeToClose: (
        /*enableEscapeToClose*/
        ctx[8]
      )
    },
    {
      closeButtonProps: (
        /*customization*/
        ctx[4].closeButtonProps
      )
    },
    /*customization*/
    ctx[4].lightboxHeaderProps || {}
  ];
  let header_props = {};
  for (let i = 0; i < header_spread_levels.length; i += 1) {
    header_props = assign(header_props, header_spread_levels[i]);
  }
  header = new LightboxHeader_default({ props: header_props, $$inline: true });
  header.$on(
    "close",
    /*close*/
    ctx[11]
  );
  body = new LightboxBody_default({
    props: {
      imagePreset: (
        /*imagePreset*/
        ctx[3]
      ),
      enableImageExpand: (
        /*enableImageExpand*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const footer_spread_levels = [
    { imagePreset: (
      /*imagePreset*/
      ctx[3]
    ) },
    { title: (
      /*title*/
      ctx[1]
    ) },
    { description: (
      /*description*/
      ctx[2]
    ) },
    /*customization*/
    ctx[4].lightboxFooterProps || {}
  ];
  let footer_props = {};
  for (let i = 0; i < footer_spread_levels.length; i += 1) {
    footer_props = assign(footer_props, footer_spread_levels[i]);
  }
  footer = new LightboxFooter_default({ props: footer_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(body.$$.fragment);
      t1 = space();
      create_component(footer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(header.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(body.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(footer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(header, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(body, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(footer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const header_changes = dirty & /*imagePreset, showCloseButton, enableEscapeToClose, customization*/
      792 ? get_spread_update(header_spread_levels, [
        dirty & /*imagePreset*/
        8 && { imagePreset: (
          /*imagePreset*/
          ctx2[3]
        ) },
        dirty & /*showCloseButton*/
        512 && {
          showCloseButton: (
            /*showCloseButton*/
            ctx2[9]
          )
        },
        dirty & /*enableEscapeToClose*/
        256 && {
          enableEscapeToClose: (
            /*enableEscapeToClose*/
            ctx2[8]
          )
        },
        dirty & /*customization*/
        16 && {
          closeButtonProps: (
            /*customization*/
            ctx2[4].closeButtonProps
          )
        },
        dirty & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].lightboxHeaderProps || {}
        )
      ]) : {};
      header.$set(header_changes);
      const body_changes = {};
      if (dirty & /*imagePreset*/
      8)
        body_changes.imagePreset = /*imagePreset*/
        ctx2[3];
      if (dirty & /*enableImageExpand*/
      64)
        body_changes.enableImageExpand = /*enableImageExpand*/
        ctx2[6];
      if (dirty & /*$$scope*/
      524288) {
        body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      body.$set(body_changes);
      const footer_changes = dirty & /*imagePreset, title, description, customization*/
      30 ? get_spread_update(footer_spread_levels, [
        dirty & /*imagePreset*/
        8 && { imagePreset: (
          /*imagePreset*/
          ctx2[3]
        ) },
        dirty & /*title*/
        2 && { title: (
          /*title*/
          ctx2[1]
        ) },
        dirty & /*description*/
        4 && { description: (
          /*description*/
          ctx2[2]
        ) },
        dirty & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].lightboxFooterProps || {}
        )
      ]) : {};
      footer.$set(footer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      transition_in(footer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      transition_out(footer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(body, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(footer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(78:3) <Modal {imagePreset} {transitionDuration} on:click={modalClick} {...(customization.lightboxProps || {})}>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let modal;
  let current;
  const modal_spread_levels = [
    { imagePreset: (
      /*imagePreset*/
      ctx[3]
    ) },
    {
      transitionDuration: (
        /*transitionDuration*/
        ctx[5]
      )
    },
    /*customization*/
    ctx[4].lightboxProps || {}
  ];
  let modal_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < modal_spread_levels.length; i += 1) {
    modal_props = assign(modal_props, modal_spread_levels[i]);
  }
  modal = new Modal_default({ props: modal_props, $$inline: true });
  modal.$on(
    "click",
    /*modalClick*/
    ctx[13]
  );
  const block = {
    c: function create() {
      create_component(modal.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modal_changes = dirty & /*imagePreset, transitionDuration, customization*/
      56 ? get_spread_update(modal_spread_levels, [
        dirty & /*imagePreset*/
        8 && { imagePreset: (
          /*imagePreset*/
          ctx2[3]
        ) },
        dirty & /*transitionDuration*/
        32 && {
          transitionDuration: (
            /*transitionDuration*/
            ctx2[5]
          )
        },
        dirty & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].lightboxProps || {}
        )
      ]) : {};
      if (dirty & /*$$scope, imagePreset, title, description, customization, enableImageExpand, showCloseButton, enableEscapeToClose*/
      525150) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(77:2) <ModalCover {transitionDuration} {...(customization.coverProps || {})} on:click={coverClick}>",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let modalcover;
  let current;
  const modalcover_spread_levels = [
    {
      transitionDuration: (
        /*transitionDuration*/
        ctx[5]
      )
    },
    /*customization*/
    ctx[4].coverProps || {}
  ];
  let modalcover_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < modalcover_spread_levels.length; i += 1) {
    modalcover_props = assign(modalcover_props, modalcover_spread_levels[i]);
  }
  modalcover = new ModalCover_default({ props: modalcover_props, $$inline: true });
  modalcover.$on(
    "click",
    /*coverClick*/
    ctx[12]
  );
  const block = {
    c: function create() {
      create_component(modalcover.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modalcover.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modalcover, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalcover_changes = dirty & /*transitionDuration, customization*/
      48 ? get_spread_update(modalcover_spread_levels, [
        dirty & /*transitionDuration*/
        32 && {
          transitionDuration: (
            /*transitionDuration*/
            ctx2[5]
          )
        },
        dirty & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].coverProps || {}
        )
      ]) : {};
      if (dirty & /*$$scope, imagePreset, transitionDuration, customization, title, description, enableImageExpand, showCloseButton, enableEscapeToClose*/
      525182) {
        modalcover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcover.$set(modalcover_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalcover.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalcover.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalcover, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(76:1) <BodyChild>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    (ctx[14].thumbnail || /*enableFallbackThumbnail*/
    ctx[7]) && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*isVisible*/
    ctx[0] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[14].thumbnail || /*enableFallbackThumbnail*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots, enableFallbackThumbnail*/
          16512) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*isVisible*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*isVisible*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Lightbox", slots, ["thumbnail", "default"]);
  const $$slots = compute_slots(slots);
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { imagePreset = "" } = $$props;
  let { customization = {} } = $$props;
  let { transitionDuration = 300 } = $$props;
  let { keepBodyScroll = false } = $$props;
  let { enableImageExpand = false } = $$props;
  let { enableFallbackThumbnail = true } = $$props;
  let { enableEscapeToClose = true } = $$props;
  let { enableClickToClose = false } = $$props;
  let { showCloseButton = true } = $$props;
  let { isVisible = false } = $$props;
  let modalClicked = false;
  const toggle = () => {
    $$invalidate(0, isVisible = !isVisible);
    toggleScroll();
  };
  const open = () => {
    $$invalidate(0, isVisible = true);
    toggleScroll();
  };
  const close = () => {
    $$invalidate(0, isVisible = false);
    toggleScroll();
  };
  const coverClick = () => {
    if (!modalClicked || enableClickToClose) {
      close();
    }
    modalClicked = false;
  };
  const modalClick = () => {
    modalClicked = true;
  };
  let toggleScroll = () => {
  };
  const programmaticController = { toggle, open, close };
  onMount(() => {
    const defaultOverflow = document.body.style.overflow;
    toggleScroll = () => {
      if (!keepBodyScroll) {
        if (isVisible) {
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = defaultOverflow;
        }
      }
    };
  });
  const writable_props = [
    "title",
    "description",
    "imagePreset",
    "customization",
    "transitionDuration",
    "keepBodyScroll",
    "enableImageExpand",
    "enableFallbackThumbnail",
    "enableEscapeToClose",
    "enableClickToClose",
    "showCloseButton",
    "isVisible"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Lightbox> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("imagePreset" in $$props2)
      $$invalidate(3, imagePreset = $$props2.imagePreset);
    if ("customization" in $$props2)
      $$invalidate(4, customization = $$props2.customization);
    if ("transitionDuration" in $$props2)
      $$invalidate(5, transitionDuration = $$props2.transitionDuration);
    if ("keepBodyScroll" in $$props2)
      $$invalidate(15, keepBodyScroll = $$props2.keepBodyScroll);
    if ("enableImageExpand" in $$props2)
      $$invalidate(6, enableImageExpand = $$props2.enableImageExpand);
    if ("enableFallbackThumbnail" in $$props2)
      $$invalidate(7, enableFallbackThumbnail = $$props2.enableFallbackThumbnail);
    if ("enableEscapeToClose" in $$props2)
      $$invalidate(8, enableEscapeToClose = $$props2.enableEscapeToClose);
    if ("enableClickToClose" in $$props2)
      $$invalidate(16, enableClickToClose = $$props2.enableClickToClose);
    if ("showCloseButton" in $$props2)
      $$invalidate(9, showCloseButton = $$props2.showCloseButton);
    if ("isVisible" in $$props2)
      $$invalidate(0, isVisible = $$props2.isVisible);
    if ("$$scope" in $$props2)
      $$invalidate(19, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Thumbnail: LightboxThumbnail_default,
    BodyChild: BodyChild_default,
    Header: LightboxHeader_default,
    Body: LightboxBody_default,
    Footer: LightboxFooter_default,
    ModalCover: ModalCover_default,
    Modal: Modal_default,
    onMount,
    title,
    description,
    imagePreset,
    customization,
    transitionDuration,
    keepBodyScroll,
    enableImageExpand,
    enableFallbackThumbnail,
    enableEscapeToClose,
    enableClickToClose,
    showCloseButton,
    isVisible,
    modalClicked,
    toggle,
    open,
    close,
    coverClick,
    modalClick,
    toggleScroll,
    programmaticController
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("imagePreset" in $$props2)
      $$invalidate(3, imagePreset = $$props2.imagePreset);
    if ("customization" in $$props2)
      $$invalidate(4, customization = $$props2.customization);
    if ("transitionDuration" in $$props2)
      $$invalidate(5, transitionDuration = $$props2.transitionDuration);
    if ("keepBodyScroll" in $$props2)
      $$invalidate(15, keepBodyScroll = $$props2.keepBodyScroll);
    if ("enableImageExpand" in $$props2)
      $$invalidate(6, enableImageExpand = $$props2.enableImageExpand);
    if ("enableFallbackThumbnail" in $$props2)
      $$invalidate(7, enableFallbackThumbnail = $$props2.enableFallbackThumbnail);
    if ("enableEscapeToClose" in $$props2)
      $$invalidate(8, enableEscapeToClose = $$props2.enableEscapeToClose);
    if ("enableClickToClose" in $$props2)
      $$invalidate(16, enableClickToClose = $$props2.enableClickToClose);
    if ("showCloseButton" in $$props2)
      $$invalidate(9, showCloseButton = $$props2.showCloseButton);
    if ("isVisible" in $$props2)
      $$invalidate(0, isVisible = $$props2.isVisible);
    if ("modalClicked" in $$props2)
      modalClicked = $$props2.modalClicked;
    if ("toggleScroll" in $$props2)
      toggleScroll = $$props2.toggleScroll;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    isVisible,
    title,
    description,
    imagePreset,
    customization,
    transitionDuration,
    enableImageExpand,
    enableFallbackThumbnail,
    enableEscapeToClose,
    showCloseButton,
    toggle,
    close,
    coverClick,
    modalClick,
    $$slots,
    keepBodyScroll,
    enableClickToClose,
    programmaticController,
    slots,
    $$scope
  ];
}
var Lightbox = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      title: 1,
      description: 2,
      imagePreset: 3,
      customization: 4,
      transitionDuration: 5,
      keepBodyScroll: 15,
      enableImageExpand: 6,
      enableFallbackThumbnail: 7,
      enableEscapeToClose: 8,
      enableClickToClose: 16,
      showCloseButton: 9,
      isVisible: 0,
      programmaticController: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Lightbox",
      options,
      id: create_fragment8.name
    });
  }
  get title() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imagePreset() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customization() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customization(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionDuration() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepBodyScroll() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepBodyScroll(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableImageExpand() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableImageExpand(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableFallbackThumbnail() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableFallbackThumbnail(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableEscapeToClose() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableEscapeToClose(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableClickToClose() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableClickToClose(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showCloseButton() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showCloseButton(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<Lightbox>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get programmaticController() {
    return this.$$.ctx[17];
  }
  set programmaticController(value) {
    throw new Error("<Lightbox>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Lightbox_default = Lightbox;

// node_modules/svelte-lightbox/dist/Gallery/PreviousImageButton.svelte
var file8 = "node_modules/svelte-lightbox/dist/Gallery/PreviousImageButton.svelte";
function add_css7(target) {
  append_styles(target, "svelte-w8nowq", "button.svelte-w8nowq{background:transparent;border:none;font-size:1rem;width:50%;height:100%}button.svelte-w8nowq:active{background:transparent}button.svelte-w8nowq:disabled{color:gray}button:disabled.hideDisabled.svelte-w8nowq{visibility:hidden}svg.svelte-w8nowq{height:5rem}.previous-button.svelte-w8nowq{position:absolute;top:0;bottom:0;left:0;right:50%;z-index:4;text-align:left}.arrow.svelte-w8nowq{fill:none;stroke:var(--svelte-lightbox-arrows-color);stroke-linecap:round;stroke-linejoin:bevel;stroke-width:1.5px;margin:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJldmlvdXNJbWFnZUJ1dHRvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBY0ksTUFBQSxjQUFBLENBQUEsQUFDSSxVQUFBLENBQUEsV0FBdUIsQ0FDdkIsTUFBQSxDQUFBLElBQVksQ0FDWixTQUFBLENBQUEsSUFBZSxDQUNmLEtBQUEsQ0FBQSxHQUFVLENBQ1YsTUFBQSxDQUFBLElBQVksQUFDaEIsQ0FBQSxBQUVBLG9CQUFBLE9BQUEsQUFBQSxDQUFBLEFBQ0ksVUFBQSxDQUFBLFdBQXVCLEFBQzNCLENBQUEsQUFFQSxvQkFBQSxTQUFBLEFBQUEsQ0FBQSxBQUNJLEtBQUEsQ0FBQSxJQUFXLEFBQ2YsQ0FBQSxBQUVBLE1BQUEsU0FBQSxhQUFBLGNBQUEsQ0FBQSxBQUNJLFVBQUEsQ0FBQSxNQUFrQixBQUN0QixDQUFBLEFBQ0EsR0FBQSxjQUFBLENBQUEsQUFDSSxNQUFBLENBQUEsSUFBWSxBQUNoQixDQUFBLEFBQ0EsZ0JBQUEsY0FBQSxDQUFBLEFBQ0ksUUFBQSxDQUFBLFFBQWtCLENBQ2xCLEdBQUEsQ0FBQSxDQUFNLENBQ04sTUFBQSxDQUFBLENBQVMsQ0FDVCxJQUFBLENBQUEsQ0FBTyxDQUNQLEtBQUEsQ0FBQSxHQUFVLENBQ1YsT0FBQSxDQUFBLENBQVUsQ0FDVixVQUFBLENBQUEsSUFBZ0IsQUFDcEIsQ0FBQSxBQUNBLE1BQUEsY0FBQSxDQUFBLEFBQ0ksSUFBQSxDQUFBLElBQVUsQ0FDVixNQUFBLENBQUEsSUFBQSw4QkFBQSxDQUEyQyxDQUMzQyxjQUFBLENBQUEsS0FBcUIsQ0FDckIsZUFBQSxDQUFBLEtBQXNCLENBQ3RCLFlBQUEsQ0FBQSxLQUFtQixDQUNuQixNQUFBLENBQUEsSUFBWSxBQUNoQixDQUFBIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlByZXZpb3VzSW1hZ2VCdXR0b24uc3ZlbHRlIl19 */");
}
function create_fragment9(ctx) {
  let button;
  let svg;
  let g;
  let path;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", { viewBox: true, xmlns: true, class: true });
      var svg_nodes = children(svg);
      g = claim_svg_element(svg_nodes, "g", {});
      var g_nodes = children(g);
      path = claim_svg_element(g_nodes, "path", { class: true, d: true });
      children(path).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "class", "arrow svelte-w8nowq");
      attr_dev(path, "d", "M8.7,7.22,4.59,11.33a1,1,0,0,0,0,1.41l4,4");
      add_location(path, file8, 8, 12, 299);
      add_location(g, file8, 7, 8, 283);
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-w8nowq");
      add_location(svg, file8, 6, 4, 214);
      button.disabled = button_disabled_value = /*character*/
      ctx[1] !== "loop" && /*activeImage*/
      ctx[0] === 0;
      attr_dev(button, "class", "previous-button svelte-w8nowq");
      toggle_class(
        button,
        "hideDisabled",
        /*character*/
        ctx[1] === "hide"
      );
      add_location(button, file8, 4, 0, 65);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, g);
      append_hydration_dev(g, path);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[2],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*character, activeImage*/
      3 && button_disabled_value !== (button_disabled_value = /*character*/
      ctx2[1] !== "loop" && /*activeImage*/
      ctx2[0] === 0)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (dirty & /*character*/
      2) {
        toggle_class(
          button,
          "hideDisabled",
          /*character*/
          ctx2[1] === "hide"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PreviousImageButton", slots, []);
  let { activeImage } = $$props;
  let { character } = $$props;
  $$self.$$.on_mount.push(function() {
    if (activeImage === void 0 && !("activeImage" in $$props || $$self.$$.bound[$$self.$$.props["activeImage"]])) {
      console.warn("<PreviousImageButton> was created without expected prop 'activeImage'");
    }
    if (character === void 0 && !("character" in $$props || $$self.$$.bound[$$self.$$.props["character"]])) {
      console.warn("<PreviousImageButton> was created without expected prop 'character'");
    }
  });
  const writable_props = ["activeImage", "character"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PreviousImageButton> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("activeImage" in $$props2)
      $$invalidate(0, activeImage = $$props2.activeImage);
    if ("character" in $$props2)
      $$invalidate(1, character = $$props2.character);
  };
  $$self.$capture_state = () => ({ activeImage, character });
  $$self.$inject_state = ($$props2) => {
    if ("activeImage" in $$props2)
      $$invalidate(0, activeImage = $$props2.activeImage);
    if ("character" in $$props2)
      $$invalidate(1, character = $$props2.character);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [activeImage, character, click_handler];
}
var PreviousImageButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { activeImage: 0, character: 1 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreviousImageButton",
      options,
      id: create_fragment9.name
    });
  }
  get activeImage() {
    throw new Error("<PreviousImageButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeImage(value) {
    throw new Error("<PreviousImageButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get character() {
    throw new Error("<PreviousImageButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set character(value) {
    throw new Error("<PreviousImageButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PreviousImageButton_default = PreviousImageButton;

// node_modules/svelte-lightbox/dist/Gallery/NextImageButton.svelte
var file9 = "node_modules/svelte-lightbox/dist/Gallery/NextImageButton.svelte";
function add_css8(target) {
  append_styles(target, "svelte-3e9wjz", "button.svelte-3e9wjz{background:transparent;border:none;font-size:1rem;width:50%;height:100%}button.svelte-3e9wjz:active{background:transparent}button.svelte-3e9wjz:disabled{color:gray}button:disabled.hideDisabled.svelte-3e9wjz{visibility:hidden}svg.svelte-3e9wjz{height:5rem}.next-button.svelte-3e9wjz{position:absolute;top:0;bottom:0;right:0;z-index:4;text-align:right}.arrow.svelte-3e9wjz{fill:none;stroke:var(--svelte-lightbox-arrows-color);stroke-linecap:round;stroke-linejoin:bevel;stroke-width:1.5px;margin:10px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmV4dEltYWdlQnV0dG9uLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFlSSxNQUFBLGNBQUEsQ0FBQSxBQUNJLFVBQUEsQ0FBQSxXQUF1QixDQUN2QixNQUFBLENBQUEsSUFBWSxDQUNaLFNBQUEsQ0FBQSxJQUFlLENBQ2YsS0FBQSxDQUFBLEdBQVUsQ0FDVixNQUFBLENBQUEsSUFBWSxBQUNoQixDQUFBLEFBRUEsb0JBQUEsT0FBQSxBQUFBLENBQUEsQUFDSSxVQUFBLENBQUEsV0FBdUIsQUFDM0IsQ0FBQSxBQUVBLG9CQUFBLFNBQUEsQUFBQSxDQUFBLEFBQ0ksS0FBQSxDQUFBLElBQVcsQUFDZixDQUFBLEFBRUEsTUFBQSxTQUFBLGFBQUEsY0FBQSxDQUFBLEFBQ0ksVUFBQSxDQUFBLE1BQWtCLEFBQ3RCLENBQUEsQUFDQSxHQUFBLGNBQUEsQ0FBQSxBQUNJLE1BQUEsQ0FBQSxJQUFZLEFBQ2hCLENBQUEsQUFDQSxZQUFBLGNBQUEsQ0FBQSxBQUNJLFFBQUEsQ0FBQSxRQUFrQixDQUNsQixHQUFBLENBQUEsQ0FBTSxDQUNOLE1BQUEsQ0FBQSxDQUFTLENBQ1QsS0FBQSxDQUFBLENBQVEsQ0FDUixPQUFBLENBQUEsQ0FBVSxDQUNWLFVBQUEsQ0FBQSxLQUFpQixBQUNyQixDQUFBLEFBQ0EsTUFBQSxjQUFBLENBQUEsQUFDSSxJQUFBLENBQUEsSUFBVSxDQUNWLE1BQUEsQ0FBQSxJQUFBLDhCQUFBLENBQTJDLENBQzNDLGNBQUEsQ0FBQSxLQUFxQixDQUNyQixlQUFBLENBQUEsS0FBc0IsQ0FDdEIsWUFBQSxDQUFBLEtBQW1CLENBQ25CLE1BQUEsQ0FBQSxJQUFZLEFBQ2hCLENBQUEiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTmV4dEltYWdlQnV0dG9uLnN2ZWx0ZSJdfQ== */");
}
function create_fragment10(ctx) {
  let button;
  let svg;
  let g;
  let path;
  let button_disabled_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      g = svg_element("g");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", { viewBox: true, xmlns: true, class: true });
      var svg_nodes = children(svg);
      g = claim_svg_element(svg_nodes, "g", {});
      var g_nodes = children(g);
      path = claim_svg_element(g_nodes, "path", { d: true, class: true });
      children(path).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.3,16.78l4.11-4.11a1,1,0,0,0,0-1.41l-4-4");
      attr_dev(path, "class", "arrow svelte-3e9wjz");
      add_location(path, file9, 9, 12, 331);
      add_location(g, file9, 8, 8, 315);
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "svelte-3e9wjz");
      add_location(svg, file9, 7, 4, 246);
      button.disabled = button_disabled_value = /*character*/
      ctx[2] !== "loop" && /*activeImage*/
      ctx[1] === /*imageCount*/
      ctx[0] - 1;
      attr_dev(button, "class", "next-button svelte-3e9wjz");
      toggle_class(
        button,
        "hideDisabled",
        /*character*/
        ctx[2] === "hide"
      );
      add_location(button, file9, 5, 0, 88);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, g);
      append_hydration_dev(g, path);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[3],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*character, activeImage, imageCount*/
      7 && button_disabled_value !== (button_disabled_value = /*character*/
      ctx2[2] !== "loop" && /*activeImage*/
      ctx2[1] === /*imageCount*/
      ctx2[0] - 1)) {
        prop_dev(button, "disabled", button_disabled_value);
      }
      if (dirty & /*character*/
      4) {
        toggle_class(
          button,
          "hideDisabled",
          /*character*/
          ctx2[2] === "hide"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NextImageButton", slots, []);
  let { imageCount } = $$props;
  let { activeImage } = $$props;
  let { character } = $$props;
  $$self.$$.on_mount.push(function() {
    if (imageCount === void 0 && !("imageCount" in $$props || $$self.$$.bound[$$self.$$.props["imageCount"]])) {
      console.warn("<NextImageButton> was created without expected prop 'imageCount'");
    }
    if (activeImage === void 0 && !("activeImage" in $$props || $$self.$$.bound[$$self.$$.props["activeImage"]])) {
      console.warn("<NextImageButton> was created without expected prop 'activeImage'");
    }
    if (character === void 0 && !("character" in $$props || $$self.$$.bound[$$self.$$.props["character"]])) {
      console.warn("<NextImageButton> was created without expected prop 'character'");
    }
  });
  const writable_props = ["imageCount", "activeImage", "character"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NextImageButton> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("imageCount" in $$props2)
      $$invalidate(0, imageCount = $$props2.imageCount);
    if ("activeImage" in $$props2)
      $$invalidate(1, activeImage = $$props2.activeImage);
    if ("character" in $$props2)
      $$invalidate(2, character = $$props2.character);
  };
  $$self.$capture_state = () => ({ imageCount, activeImage, character });
  $$self.$inject_state = ($$props2) => {
    if ("imageCount" in $$props2)
      $$invalidate(0, imageCount = $$props2.imageCount);
    if ("activeImage" in $$props2)
      $$invalidate(1, activeImage = $$props2.activeImage);
    if ("character" in $$props2)
      $$invalidate(2, character = $$props2.character);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageCount, activeImage, character, click_handler];
}
var NextImageButton = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance10,
      create_fragment10,
      safe_not_equal,
      {
        imageCount: 0,
        activeImage: 1,
        character: 2
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NextImageButton",
      options,
      id: create_fragment10.name
    });
  }
  get imageCount() {
    throw new Error("<NextImageButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageCount(value) {
    throw new Error("<NextImageButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeImage() {
    throw new Error("<NextImageButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeImage(value) {
    throw new Error("<NextImageButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get character() {
    throw new Error("<NextImageButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set character(value) {
    throw new Error("<NextImageButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NextImageButton_default = NextImageButton;

// node_modules/svelte-lightbox/dist/Gallery/GalleryController.svelte
function create_fragment11(ctx) {
  let previousimagebutton;
  let div;
  let __svelte_lightbox_arrows_color_last;
  let t0;
  let t1;
  let nextimagebutton;
  let div_1;
  let __svelte_lightbox_arrows_color_last_1;
  let current;
  let mounted;
  let dispose;
  previousimagebutton = new PreviousImageButton_default({
    props: {
      activeImage: (
        /*$activeImageStore*/
        ctx[4]
      ),
      character: (
        /*$arrowsConfigStore*/
        ctx[3].character
      )
    },
    $$inline: true
  });
  previousimagebutton.$on(
    "click",
    /*previousImage*/
    ctx[6]
  );
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  nextimagebutton = new NextImageButton_default({
    props: {
      activeImage: (
        /*$activeImageStore*/
        ctx[4]
      ),
      imageCount: (
        /*$imageCountStore*/
        ctx[5]
      ),
      character: (
        /*$arrowsConfigStore*/
        ctx[3].character
      )
    },
    $$inline: true
  });
  nextimagebutton.$on(
    "click",
    /*nextImage*/
    ctx[7]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(previousimagebutton.$$.fragment);
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      div_1 = element("div");
      create_component(nextimagebutton.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      var div_nodes = children(div);
      claim_component(previousimagebutton.$$.fragment, div_nodes);
      t0 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t1 = claim_space(nodes);
      div_1 = claim_element(nodes, "DIV", { style: true });
      var div_1_nodes = children(div_1);
      claim_component(nextimagebutton.$$.fragment, div_1_nodes);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "display", "contents");
      set_style(div, "--svelte-lightbox-arrows-color", __svelte_lightbox_arrows_color_last = /*$arrowsConfigStore*/
      ctx[3].color);
      set_style(div_1, "display", "contents");
      set_style(div_1, "--svelte-lightbox-arrows-color", __svelte_lightbox_arrows_color_last_1 = /*$arrowsConfigStore*/
      ctx[3].color);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(previousimagebutton, div, null);
      insert_hydration_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div_1, anchor);
      mount_component(nextimagebutton, div_1, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "keydown",
          /*keydown_handler*/
          ctx[12],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$arrowsConfigStore*/
      8 && __svelte_lightbox_arrows_color_last !== (__svelte_lightbox_arrows_color_last = /*$arrowsConfigStore*/
      ctx2[3].color)) {
        set_style(div, "--svelte-lightbox-arrows-color", __svelte_lightbox_arrows_color_last);
      }
      const previousimagebutton_changes = {};
      if (dirty & /*$activeImageStore*/
      16)
        previousimagebutton_changes.activeImage = /*$activeImageStore*/
        ctx2[4];
      if (dirty & /*$arrowsConfigStore*/
      8)
        previousimagebutton_changes.character = /*$arrowsConfigStore*/
        ctx2[3].character;
      previousimagebutton.$set(previousimagebutton_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (dirty & /*$arrowsConfigStore*/
      8 && __svelte_lightbox_arrows_color_last_1 !== (__svelte_lightbox_arrows_color_last_1 = /*$arrowsConfigStore*/
      ctx2[3].color)) {
        set_style(div_1, "--svelte-lightbox-arrows-color", __svelte_lightbox_arrows_color_last_1);
      }
      const nextimagebutton_changes = {};
      if (dirty & /*$activeImageStore*/
      16)
        nextimagebutton_changes.activeImage = /*$activeImageStore*/
        ctx2[4];
      if (dirty & /*$imageCountStore*/
      32)
        nextimagebutton_changes.imageCount = /*$imageCountStore*/
        ctx2[5];
      if (dirty & /*$arrowsConfigStore*/
      8)
        nextimagebutton_changes.character = /*$arrowsConfigStore*/
        ctx2[3].character;
      nextimagebutton.$set(nextimagebutton_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(previousimagebutton.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(nextimagebutton.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previousimagebutton.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(nextimagebutton.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching && previousimagebutton)
        detach_dev(div);
      destroy_component(previousimagebutton, detaching);
      if (detaching)
        detach_dev(t0);
      if (default_slot)
        default_slot.d(detaching);
      if (detaching)
        detach_dev(t1);
      if (detaching && nextimagebutton)
        detach_dev(div_1);
      destroy_component(nextimagebutton, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let fullscreen;
  let $arrowsConfigStore, $$unsubscribe_arrowsConfigStore = noop, $$subscribe_arrowsConfigStore = () => ($$unsubscribe_arrowsConfigStore(), $$unsubscribe_arrowsConfigStore = subscribe(arrowsConfigStore, ($$value) => $$invalidate(3, $arrowsConfigStore = $$value)), arrowsConfigStore);
  let $activeImageStore, $$unsubscribe_activeImageStore = noop, $$subscribe_activeImageStore = () => ($$unsubscribe_activeImageStore(), $$unsubscribe_activeImageStore = subscribe(activeImageStore, ($$value) => $$invalidate(4, $activeImageStore = $$value)), activeImageStore);
  let $imageCountStore, $$unsubscribe_imageCountStore = noop, $$subscribe_imageCountStore = () => ($$unsubscribe_imageCountStore(), $$unsubscribe_imageCountStore = subscribe(imageCountStore, ($$value) => $$invalidate(5, $imageCountStore = $$value)), imageCountStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_arrowsConfigStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeImageStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_imageCountStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GalleryController", slots, ["default"]);
  let { imagePreset = "" } = $$props;
  let { imageCountStore } = $$props;
  validate_store(imageCountStore, "imageCountStore");
  $$subscribe_imageCountStore();
  let { activeImageStore } = $$props;
  validate_store(activeImageStore, "activeImageStore");
  $$subscribe_activeImageStore();
  let { arrowsConfigStore } = $$props;
  validate_store(arrowsConfigStore, "arrowsConfigStore");
  $$subscribe_arrowsConfigStore();
  const previousImage = () => {
    if ($activeImageStore === 0) {
      if ($arrowsConfigStore.character === "loop") {
        activeImageStore.set($imageCountStore - 1);
      }
    } else {
      activeImageStore.set($activeImageStore - 1);
    }
  };
  const nextImage = () => {
    if ($activeImageStore === $imageCountStore - 1) {
      if ($arrowsConfigStore.character === "loop") {
        activeImageStore.set(0);
      }
    } else {
      activeImageStore.set($activeImageStore + 1);
    }
  };
  const handleKey = (event) => {
    if ($arrowsConfigStore.enableKeyboardControl) {
      switch (event.key) {
        case "ArrowLeft": {
          previousImage();
          break;
        }
        case "ArrowRight": {
          nextImage();
          break;
        }
      }
    }
  };
  $$self.$$.on_mount.push(function() {
    if (imageCountStore === void 0 && !("imageCountStore" in $$props || $$self.$$.bound[$$self.$$.props["imageCountStore"]])) {
      console.warn("<GalleryController> was created without expected prop 'imageCountStore'");
    }
    if (activeImageStore === void 0 && !("activeImageStore" in $$props || $$self.$$.bound[$$self.$$.props["activeImageStore"]])) {
      console.warn("<GalleryController> was created without expected prop 'activeImageStore'");
    }
    if (arrowsConfigStore === void 0 && !("arrowsConfigStore" in $$props || $$self.$$.bound[$$self.$$.props["arrowsConfigStore"]])) {
      console.warn("<GalleryController> was created without expected prop 'arrowsConfigStore'");
    }
  });
  const writable_props = ["imagePreset", "imageCountStore", "activeImageStore", "arrowsConfigStore"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<GalleryController> was created with unknown prop '${key}'`);
  });
  const keydown_handler = (event) => handleKey(event);
  $$self.$$set = ($$props2) => {
    if ("imagePreset" in $$props2)
      $$invalidate(9, imagePreset = $$props2.imagePreset);
    if ("imageCountStore" in $$props2)
      $$subscribe_imageCountStore($$invalidate(0, imageCountStore = $$props2.imageCountStore));
    if ("activeImageStore" in $$props2)
      $$subscribe_activeImageStore($$invalidate(1, activeImageStore = $$props2.activeImageStore));
    if ("arrowsConfigStore" in $$props2)
      $$subscribe_arrowsConfigStore($$invalidate(2, arrowsConfigStore = $$props2.arrowsConfigStore));
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    PreviousImageButton: PreviousImageButton_default,
    NextImageButton: NextImageButton_default,
    imagePreset,
    imageCountStore,
    activeImageStore,
    arrowsConfigStore,
    previousImage,
    nextImage,
    handleKey,
    fullscreen,
    $arrowsConfigStore,
    $activeImageStore,
    $imageCountStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("imagePreset" in $$props2)
      $$invalidate(9, imagePreset = $$props2.imagePreset);
    if ("imageCountStore" in $$props2)
      $$subscribe_imageCountStore($$invalidate(0, imageCountStore = $$props2.imageCountStore));
    if ("activeImageStore" in $$props2)
      $$subscribe_activeImageStore($$invalidate(1, activeImageStore = $$props2.activeImageStore));
    if ("arrowsConfigStore" in $$props2)
      $$subscribe_arrowsConfigStore($$invalidate(2, arrowsConfigStore = $$props2.arrowsConfigStore));
    if ("fullscreen" in $$props2)
      fullscreen = $$props2.fullscreen;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*imagePreset*/
    512) {
      $:
        fullscreen = imagePreset === "fullscreen";
    }
  };
  return [
    imageCountStore,
    activeImageStore,
    arrowsConfigStore,
    $arrowsConfigStore,
    $activeImageStore,
    $imageCountStore,
    previousImage,
    nextImage,
    handleKey,
    imagePreset,
    $$scope,
    slots,
    keydown_handler
  ];
}
var GalleryController = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      imagePreset: 9,
      imageCountStore: 0,
      activeImageStore: 1,
      arrowsConfigStore: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GalleryController",
      options,
      id: create_fragment11.name
    });
  }
  get imagePreset() {
    throw new Error("<GalleryController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<GalleryController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageCountStore() {
    throw new Error("<GalleryController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageCountStore(value) {
    throw new Error("<GalleryController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeImageStore() {
    throw new Error("<GalleryController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeImageStore(value) {
    throw new Error("<GalleryController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowsConfigStore() {
    throw new Error("<GalleryController>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowsConfigStore(value) {
    throw new Error("<GalleryController>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GalleryController_default = GalleryController;

// node_modules/svelte-lightbox/dist/Gallery/Gallery.svelte
var get_thumbnail_slot_changes2 = (dirty) => ({});
var get_thumbnail_slot_context2 = (ctx) => ({});
function create_if_block_12(ctx) {
  let current;
  const thumbnail_slot_template = (
    /*#slots*/
    ctx[25].thumbnail
  );
  const thumbnail_slot = create_slot(
    thumbnail_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    get_thumbnail_slot_context2
  );
  const block = {
    c: function create() {
      if (thumbnail_slot)
        thumbnail_slot.c();
    },
    l: function claim(nodes) {
      if (thumbnail_slot)
        thumbnail_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (thumbnail_slot) {
        thumbnail_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (thumbnail_slot) {
        if (thumbnail_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            thumbnail_slot,
            thumbnail_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              thumbnail_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              get_thumbnail_slot_changes2
            ),
            get_thumbnail_slot_context2
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(thumbnail_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(thumbnail_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (thumbnail_slot)
        thumbnail_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(106:0) {#if $$slots.thumbnail}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let bodychild;
  let current;
  bodychild = new BodyChild_default({
    props: {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(bodychild.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(bodychild.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(bodychild, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bodychild_changes = {};
      if (dirty[0] & /*$$scope, transitionDuration, customization, imagePreset, title, description, gallery, enableImageExpand, showCloseButton, enableEscapeToClose*/
      67109886) {
        bodychild_changes.$$scope = { dirty, ctx: ctx2 };
      }
      bodychild.$set(bodychild_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(bodychild.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bodychild.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bodychild, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(110:0) {#if isVisible}",
    ctx
  });
  return block;
}
function create_default_slot_42(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[25].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[26],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        67108864)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[26],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[26]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[26],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_42.name,
    type: "slot",
    source: "(118:24) <GalleryController {imagePreset} {imageCountStore} {activeImageStore} {arrowsConfigStore}>",
    ctx
  });
  return block;
}
function create_default_slot_32(ctx) {
  let gallerycontroller;
  let current;
  gallerycontroller = new GalleryController_default({
    props: {
      imagePreset: (
        /*imagePreset*/
        ctx[3]
      ),
      imageCountStore: (
        /*imageCountStore*/
        ctx[10]
      ),
      activeImageStore: (
        /*activeImageStore*/
        ctx[11]
      ),
      arrowsConfigStore: (
        /*arrowsConfigStore*/
        ctx[12]
      ),
      $$slots: { default: [create_default_slot_42] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(gallerycontroller.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(gallerycontroller.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(gallerycontroller, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const gallerycontroller_changes = {};
      if (dirty[0] & /*imagePreset*/
      8)
        gallerycontroller_changes.imagePreset = /*imagePreset*/
        ctx2[3];
      if (dirty[0] & /*$$scope*/
      67108864) {
        gallerycontroller_changes.$$scope = { dirty, ctx: ctx2 };
      }
      gallerycontroller.$set(gallerycontroller_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(gallerycontroller.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(gallerycontroller.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(gallerycontroller, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_32.name,
    type: "slot",
    source: "(117:20) <Body {imagePreset} {enableImageExpand}>",
    ctx
  });
  return block;
}
function create_default_slot_22(ctx) {
  let header;
  let t0;
  let body;
  let t1;
  let footer;
  let current;
  const header_spread_levels = [
    { imagePreset: (
      /*imagePreset*/
      ctx[3]
    ) },
    {
      showCloseButton: (
        /*showCloseButton*/
        ctx[8]
      )
    },
    {
      enableEscapeToClose: (
        /*enableEscapeToClose*/
        ctx[7]
      )
    },
    {
      closeButtonProps: (
        /*customization*/
        ctx[4].closeButtonProps
      )
    },
    /*customization*/
    ctx[4].lightboxHeaderProps || {}
  ];
  let header_props = {};
  for (let i = 0; i < header_spread_levels.length; i += 1) {
    header_props = assign(header_props, header_spread_levels[i]);
  }
  header = new LightboxHeader_default({ props: header_props, $$inline: true });
  header.$on(
    "close",
    /*close*/
    ctx[13]
  );
  body = new LightboxBody_default({
    props: {
      imagePreset: (
        /*imagePreset*/
        ctx[3]
      ),
      enableImageExpand: (
        /*enableImageExpand*/
        ctx[6]
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const footer_spread_levels = [
    { imagePreset: (
      /*imagePreset*/
      ctx[3]
    ) },
    { title: (
      /*title*/
      ctx[1]
    ) },
    { description: (
      /*description*/
      ctx[2]
    ) },
    { gallery: (
      /*gallery*/
      ctx[9]
    ) },
    /*customization*/
    ctx[4].lightboxFooterProps || {}
  ];
  let footer_props = {};
  for (let i = 0; i < footer_spread_levels.length; i += 1) {
    footer_props = assign(footer_props, footer_spread_levels[i]);
  }
  footer = new LightboxFooter_default({ props: footer_props, $$inline: true });
  const block = {
    c: function create() {
      create_component(header.$$.fragment);
      t0 = space();
      create_component(body.$$.fragment);
      t1 = space();
      create_component(footer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(header.$$.fragment, nodes);
      t0 = claim_space(nodes);
      claim_component(body.$$.fragment, nodes);
      t1 = claim_space(nodes);
      claim_component(footer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(header, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      mount_component(body, target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(footer, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const header_changes = dirty[0] & /*imagePreset, showCloseButton, enableEscapeToClose, customization*/
      408 ? get_spread_update(header_spread_levels, [
        dirty[0] & /*imagePreset*/
        8 && { imagePreset: (
          /*imagePreset*/
          ctx2[3]
        ) },
        dirty[0] & /*showCloseButton*/
        256 && {
          showCloseButton: (
            /*showCloseButton*/
            ctx2[8]
          )
        },
        dirty[0] & /*enableEscapeToClose*/
        128 && {
          enableEscapeToClose: (
            /*enableEscapeToClose*/
            ctx2[7]
          )
        },
        dirty[0] & /*customization*/
        16 && {
          closeButtonProps: (
            /*customization*/
            ctx2[4].closeButtonProps
          )
        },
        dirty[0] & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].lightboxHeaderProps || {}
        )
      ]) : {};
      header.$set(header_changes);
      const body_changes = {};
      if (dirty[0] & /*imagePreset*/
      8)
        body_changes.imagePreset = /*imagePreset*/
        ctx2[3];
      if (dirty[0] & /*enableImageExpand*/
      64)
        body_changes.enableImageExpand = /*enableImageExpand*/
        ctx2[6];
      if (dirty[0] & /*$$scope, imagePreset*/
      67108872) {
        body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      body.$set(body_changes);
      const footer_changes = dirty[0] & /*imagePreset, title, description, gallery, customization*/
      542 ? get_spread_update(footer_spread_levels, [
        dirty[0] & /*imagePreset*/
        8 && { imagePreset: (
          /*imagePreset*/
          ctx2[3]
        ) },
        dirty[0] & /*title*/
        2 && { title: (
          /*title*/
          ctx2[1]
        ) },
        dirty[0] & /*description*/
        4 && { description: (
          /*description*/
          ctx2[2]
        ) },
        dirty[0] & /*gallery*/
        512 && { gallery: (
          /*gallery*/
          ctx2[9]
        ) },
        dirty[0] & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].lightboxFooterProps || {}
        )
      ]) : {};
      footer.$set(footer_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(body.$$.fragment, local);
      transition_in(footer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      transition_out(body.$$.fragment, local);
      transition_out(footer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach_dev(t0);
      destroy_component(body, detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(footer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_22.name,
    type: "slot",
    source: "(113:12) <Modal {imagePreset} {transitionDuration} {...(customization.lightboxProps || {})} on:click={modalClick}>",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let modal;
  let current;
  const modal_spread_levels = [
    { imagePreset: (
      /*imagePreset*/
      ctx[3]
    ) },
    {
      transitionDuration: (
        /*transitionDuration*/
        ctx[5]
      )
    },
    /*customization*/
    ctx[4].lightboxProps || {}
  ];
  let modal_props = {
    $$slots: { default: [create_default_slot_22] },
    $$scope: { ctx }
  };
  for (let i = 0; i < modal_spread_levels.length; i += 1) {
    modal_props = assign(modal_props, modal_spread_levels[i]);
  }
  modal = new Modal_default({ props: modal_props, $$inline: true });
  modal.$on(
    "click",
    /*modalClick*/
    ctx[15]
  );
  const block = {
    c: function create() {
      create_component(modal.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modal.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modal_changes = dirty[0] & /*imagePreset, transitionDuration, customization*/
      56 ? get_spread_update(modal_spread_levels, [
        dirty[0] & /*imagePreset*/
        8 && { imagePreset: (
          /*imagePreset*/
          ctx2[3]
        ) },
        dirty[0] & /*transitionDuration*/
        32 && {
          transitionDuration: (
            /*transitionDuration*/
            ctx2[5]
          )
        },
        dirty[0] & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].lightboxProps || {}
        )
      ]) : {};
      if (dirty[0] & /*$$scope, imagePreset, title, description, gallery, customization, enableImageExpand, showCloseButton, enableEscapeToClose*/
      67109854) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(112:8) <ModalCover {transitionDuration} {...(customization.coverProps || {})} on:click={coverClick}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let modalcover;
  let current;
  const modalcover_spread_levels = [
    {
      transitionDuration: (
        /*transitionDuration*/
        ctx[5]
      )
    },
    /*customization*/
    ctx[4].coverProps || {}
  ];
  let modalcover_props = {
    $$slots: { default: [create_default_slot_12] },
    $$scope: { ctx }
  };
  for (let i = 0; i < modalcover_spread_levels.length; i += 1) {
    modalcover_props = assign(modalcover_props, modalcover_spread_levels[i]);
  }
  modalcover = new ModalCover_default({ props: modalcover_props, $$inline: true });
  modalcover.$on(
    "click",
    /*coverClick*/
    ctx[14]
  );
  const block = {
    c: function create() {
      create_component(modalcover.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(modalcover.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(modalcover, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modalcover_changes = dirty[0] & /*transitionDuration, customization*/
      48 ? get_spread_update(modalcover_spread_levels, [
        dirty[0] & /*transitionDuration*/
        32 && {
          transitionDuration: (
            /*transitionDuration*/
            ctx2[5]
          )
        },
        dirty[0] & /*customization*/
        16 && get_spread_object(
          /*customization*/
          ctx2[4].coverProps || {}
        )
      ]) : {};
      if (dirty[0] & /*$$scope, imagePreset, transitionDuration, customization, title, description, gallery, enableImageExpand, showCloseButton, enableEscapeToClose*/
      67109886) {
        modalcover_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modalcover.$set(modalcover_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modalcover.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modalcover.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modalcover, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(111:4) <BodyChild>",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*$$slots*/
    ctx[16].thumbnail && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*isVisible*/
    ctx[0] && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[16].thumbnail
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          65536) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*isVisible*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*isVisible*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let activeImageTitle;
  let activeImageDescription;
  let gallery;
  let $activeImageStore;
  let $imageCountStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Gallery", slots, ["thumbnail", "default"]);
  const $$slots = compute_slots(slots);
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  let { imagePreset = "" } = $$props;
  let { customization = {} } = $$props;
  let { transitionDuration = 300 } = $$props;
  let { keepBodyScroll = false } = $$props;
  let { enableImageExpand = false } = $$props;
  let { enableEscapeToClose = true } = $$props;
  let { enableClickToClose = false } = $$props;
  let { showCloseButton = true } = $$props;
  let { isVisible = false } = $$props;
  let { activeImage = 0 } = $$props;
  let { arrowsConfig = {
    color: "black",
    character: "",
    enableKeyboardControl: true
  } } = $$props;
  let modalClicked = false;
  let images = [];
  let thumbnailCount = 0;
  const imageCountStore = writable(images.length);
  validate_store(imageCountStore, "imageCountStore");
  component_subscribe($$self, imageCountStore, (value) => $$invalidate(24, $imageCountStore = value));
  const activeImageStore = writable(activeImage);
  validate_store(activeImageStore, "activeImageStore");
  component_subscribe($$self, activeImageStore, (value) => $$invalidate(23, $activeImageStore = value));
  const arrowsConfigStore = writable(arrowsConfig);
  const toggle = () => {
    $$invalidate(0, isVisible = !isVisible);
    toggleScroll();
  };
  const open = () => {
    $$invalidate(0, isVisible = true);
    toggleScroll();
  };
  const openImage = (imageId) => {
    open();
    $$invalidate(17, activeImage = imageId);
  };
  const close = () => {
    $$invalidate(0, isVisible = false);
    toggleScroll();
  };
  const coverClick = () => {
    if (!modalClicked || enableClickToClose) {
      close();
    }
    modalClicked = false;
  };
  const modalClick = () => {
    modalClicked = true;
  };
  const keepOrEmptyImageList = (isVisible2) => {
    if (!isVisible2)
      $$invalidate(22, images = []);
  };
  let toggleScroll = () => {
  };
  const programmaticController = { toggle, open, close, openImage };
  setContext("activeImage", activeImageStore);
  setContext("imageCounter", (image) => {
    image.id = images.length;
    $$invalidate(22, images = [...images, image]);
    set_store_value(imageCountStore, $imageCountStore = images.length, $imageCountStore);
    return $imageCountStore - 1;
  });
  setContext("thumbnailCounter", () => {
    return thumbnailCount++;
  });
  setContext("openImage", openImage);
  onMount(() => {
    const defaultOverflow = document.body.style.overflow;
    toggleScroll = () => {
      if (!keepBodyScroll) {
        if (isVisible) {
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = defaultOverflow;
        }
      }
    };
  });
  const writable_props = [
    "title",
    "description",
    "imagePreset",
    "customization",
    "transitionDuration",
    "keepBodyScroll",
    "enableImageExpand",
    "enableEscapeToClose",
    "enableClickToClose",
    "showCloseButton",
    "isVisible",
    "activeImage",
    "arrowsConfig"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Gallery> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("imagePreset" in $$props2)
      $$invalidate(3, imagePreset = $$props2.imagePreset);
    if ("customization" in $$props2)
      $$invalidate(4, customization = $$props2.customization);
    if ("transitionDuration" in $$props2)
      $$invalidate(5, transitionDuration = $$props2.transitionDuration);
    if ("keepBodyScroll" in $$props2)
      $$invalidate(18, keepBodyScroll = $$props2.keepBodyScroll);
    if ("enableImageExpand" in $$props2)
      $$invalidate(6, enableImageExpand = $$props2.enableImageExpand);
    if ("enableEscapeToClose" in $$props2)
      $$invalidate(7, enableEscapeToClose = $$props2.enableEscapeToClose);
    if ("enableClickToClose" in $$props2)
      $$invalidate(19, enableClickToClose = $$props2.enableClickToClose);
    if ("showCloseButton" in $$props2)
      $$invalidate(8, showCloseButton = $$props2.showCloseButton);
    if ("isVisible" in $$props2)
      $$invalidate(0, isVisible = $$props2.isVisible);
    if ("activeImage" in $$props2)
      $$invalidate(17, activeImage = $$props2.activeImage);
    if ("arrowsConfig" in $$props2)
      $$invalidate(20, arrowsConfig = $$props2.arrowsConfig);
    if ("$$scope" in $$props2)
      $$invalidate(26, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    writable,
    GalleryController: GalleryController_default,
    BodyChild: BodyChild_default,
    Header: LightboxHeader_default,
    Body: LightboxBody_default,
    Footer: LightboxFooter_default,
    ModalCover: ModalCover_default,
    Modal: Modal_default,
    title,
    description,
    imagePreset,
    customization,
    transitionDuration,
    keepBodyScroll,
    enableImageExpand,
    enableEscapeToClose,
    enableClickToClose,
    showCloseButton,
    isVisible,
    activeImage,
    arrowsConfig,
    modalClicked,
    images,
    thumbnailCount,
    imageCountStore,
    activeImageStore,
    arrowsConfigStore,
    toggle,
    open,
    openImage,
    close,
    coverClick,
    modalClick,
    keepOrEmptyImageList,
    toggleScroll,
    programmaticController,
    gallery,
    activeImageDescription,
    activeImageTitle,
    $activeImageStore,
    $imageCountStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(1, title = $$props2.title);
    if ("description" in $$props2)
      $$invalidate(2, description = $$props2.description);
    if ("imagePreset" in $$props2)
      $$invalidate(3, imagePreset = $$props2.imagePreset);
    if ("customization" in $$props2)
      $$invalidate(4, customization = $$props2.customization);
    if ("transitionDuration" in $$props2)
      $$invalidate(5, transitionDuration = $$props2.transitionDuration);
    if ("keepBodyScroll" in $$props2)
      $$invalidate(18, keepBodyScroll = $$props2.keepBodyScroll);
    if ("enableImageExpand" in $$props2)
      $$invalidate(6, enableImageExpand = $$props2.enableImageExpand);
    if ("enableEscapeToClose" in $$props2)
      $$invalidate(7, enableEscapeToClose = $$props2.enableEscapeToClose);
    if ("enableClickToClose" in $$props2)
      $$invalidate(19, enableClickToClose = $$props2.enableClickToClose);
    if ("showCloseButton" in $$props2)
      $$invalidate(8, showCloseButton = $$props2.showCloseButton);
    if ("isVisible" in $$props2)
      $$invalidate(0, isVisible = $$props2.isVisible);
    if ("activeImage" in $$props2)
      $$invalidate(17, activeImage = $$props2.activeImage);
    if ("arrowsConfig" in $$props2)
      $$invalidate(20, arrowsConfig = $$props2.arrowsConfig);
    if ("modalClicked" in $$props2)
      modalClicked = $$props2.modalClicked;
    if ("images" in $$props2)
      $$invalidate(22, images = $$props2.images);
    if ("thumbnailCount" in $$props2)
      thumbnailCount = $$props2.thumbnailCount;
    if ("toggleScroll" in $$props2)
      toggleScroll = $$props2.toggleScroll;
    if ("gallery" in $$props2)
      $$invalidate(9, gallery = $$props2.gallery);
    if ("activeImageDescription" in $$props2)
      activeImageDescription = $$props2.activeImageDescription;
    if ("activeImageTitle" in $$props2)
      activeImageTitle = $$props2.activeImageTitle;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*activeImage*/
    131072) {
      $:
        activeImageStore.set(activeImage);
    }
    if ($$self.$$.dirty[0] & /*arrowsConfig*/
    1048576) {
      $:
        arrowsConfigStore.set(arrowsConfig);
    }
    if ($$self.$$.dirty[0] & /*isVisible*/
    1) {
      $:
        keepOrEmptyImageList(isVisible);
    }
    if ($$self.$$.dirty[0] & /*images, $activeImageStore, title*/
    12582914) {
      $:
        activeImageTitle = images[$activeImageStore]?.title || title || "";
    }
    if ($$self.$$.dirty[0] & /*images, $activeImageStore, description*/
    12582916) {
      $:
        activeImageDescription = images[$activeImageStore]?.description || description || "";
    }
    if ($$self.$$.dirty[0] & /*$imageCountStore, $activeImageStore*/
    25165824) {
      $:
        $$invalidate(9, gallery = {
          imageCount: $imageCountStore,
          activeImage: $activeImageStore
        });
    }
  };
  return [
    isVisible,
    title,
    description,
    imagePreset,
    customization,
    transitionDuration,
    enableImageExpand,
    enableEscapeToClose,
    showCloseButton,
    gallery,
    imageCountStore,
    activeImageStore,
    arrowsConfigStore,
    close,
    coverClick,
    modalClick,
    $$slots,
    activeImage,
    keepBodyScroll,
    enableClickToClose,
    arrowsConfig,
    programmaticController,
    images,
    $activeImageStore,
    $imageCountStore,
    slots,
    $$scope
  ];
}
var Gallery = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance12,
      create_fragment12,
      safe_not_equal,
      {
        title: 1,
        description: 2,
        imagePreset: 3,
        customization: 4,
        transitionDuration: 5,
        keepBodyScroll: 18,
        enableImageExpand: 6,
        enableEscapeToClose: 7,
        enableClickToClose: 19,
        showCloseButton: 8,
        isVisible: 0,
        activeImage: 17,
        arrowsConfig: 20,
        programmaticController: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gallery",
      options,
      id: create_fragment12.name
    });
  }
  get title() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imagePreset() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imagePreset(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get customization() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set customization(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transitionDuration() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transitionDuration(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepBodyScroll() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepBodyScroll(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableImageExpand() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableImageExpand(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableEscapeToClose() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableEscapeToClose(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get enableClickToClose() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set enableClickToClose(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showCloseButton() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showCloseButton(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isVisible() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isVisible(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activeImage() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activeImage(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get arrowsConfig() {
    throw new Error("<Gallery>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set arrowsConfig(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get programmaticController() {
    return this.$$.ctx[21];
  }
  set programmaticController(value) {
    throw new Error("<Gallery>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Gallery_default = Gallery;

// node_modules/svelte-lightbox/dist/Gallery/GalleryThumbnail.svelte
var file10 = "node_modules/svelte-lightbox/dist/Gallery/GalleryThumbnail.svelte";
function add_css9(target) {
  append_styles(target, "svelte-fkcut5", "div.svelte-fkcut5{position:static;cursor:zoom-in}.svelte-lightbox-thumbnail > *{max-width:100%;height:auto}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FsbGVyeVRodW1ibmFpbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBYUksR0FBQSxjQUFBLENBQUEsQUFDSSxRQUFBLENBQUEsTUFBZ0IsQ0FDaEIsTUFBQSxDQUFBLE9BQWUsQUFDbkIsQ0FBQSxBQUNBLDhCQUFBLEFBQUEsQ0FBQSxBQUNJLFNBQUEsQ0FBQSxJQUFlLENBQ2YsTUFBQSxDQUFBLElBQVksQUFDaEIsQ0FBQSIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJHYWxsZXJ5VGh1bWJuYWlsLnN2ZWx0ZSJdfQ== */");
}
function create_fragment13(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  let div_levels = [
    /*$$restProps*/
    ctx[2]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      toggle_class(div, "svelte-lightbox-thumbnail", true);
      toggle_class(div, "svelte-fkcut5", true);
      add_location(div, file10, 8, 0, 172);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*click_handler*/
          ctx[5],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/
      4 && /*$$restProps*/
      ctx2[2]]));
      toggle_class(div, "svelte-lightbox-thumbnail", true);
      toggle_class(div, "svelte-fkcut5", true);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  const omit_props_names = ["id"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GalleryThumbnail", slots, ["default"]);
  let { id } = $$props;
  const openImage = getContext("openImage");
  if (!id) {
    id = getContext("thumbnailCounter")();
  }
  $$self.$$.on_mount.push(function() {
    if (id === void 0 && !("id" in $$props || $$self.$$.bound[$$self.$$.props["id"]])) {
      console.warn("<GalleryThumbnail> was created without expected prop 'id'");
    }
  });
  const click_handler = () => openImage(id);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("id" in $$new_props)
      $$invalidate(0, id = $$new_props.id);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ getContext, id, openImage });
  $$self.$inject_state = ($$new_props) => {
    if ("id" in $$props)
      $$invalidate(0, id = $$new_props.id);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [id, openImage, $$restProps, $$scope, slots, click_handler];
}
var GalleryThumbnail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { id: 0 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GalleryThumbnail",
      options,
      id: create_fragment13.name
    });
  }
  get id() {
    throw new Error("<GalleryThumbnail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<GalleryThumbnail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GalleryThumbnail_default = GalleryThumbnail;

// node_modules/svelte-lightbox/dist/Gallery/GalleryImage.svelte
function add_css10(target) {
  append_styles(target, "svelte-11yzrhs", "\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FsbGVyeUltYWdlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdF9ydG1hdi9kb3h4ZWQtcG9ydG9mbGlvLXNpdGUvbm9kZV9tb2R1bGVzL3N2ZWx0ZS1saWdodGJveC9kaXN0L0dhbGxlcnkvR2FsbGVyeUltYWdlLnN2ZWx0ZSJdfQ== */");
}
var get_default_slot_spread_changes = (dirty) => dirty & /*$$restProps*/
8;
var get_default_slot_changes = (dirty) => ({});
var get_default_slot_context = (ctx) => ({ .../*$$restProps*/
ctx[3] });
function create_if_block5(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    get_default_slot_context
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope, $$restProps*/
        72)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            get_default_slot_spread_changes(dirty) || !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(11:0) {#if $activeImageStore === imageId}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$activeImageStore*/
    ctx[0] === /*imageId*/
    ctx[2] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$activeImageStore*/
        ctx2[0] === /*imageId*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$activeImageStore*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  const omit_props_names = ["title", "description"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $activeImageStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("GalleryImage", slots, ["default"]);
  let { title = "" } = $$props;
  let { description = "" } = $$props;
  const activeImageStore = getContext("activeImage");
  validate_store(activeImageStore, "activeImageStore");
  component_subscribe($$self, activeImageStore, (value) => $$invalidate(0, $activeImageStore = value));
  const imageId = getContext("imageCounter")({ title, description });
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("title" in $$new_props)
      $$invalidate(4, title = $$new_props.title);
    if ("description" in $$new_props)
      $$invalidate(5, description = $$new_props.description);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    title,
    description,
    activeImageStore,
    imageId,
    $activeImageStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("title" in $$props)
      $$invalidate(4, title = $$new_props.title);
    if ("description" in $$props)
      $$invalidate(5, description = $$new_props.description);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $activeImageStore,
    activeImageStore,
    imageId,
    $$restProps,
    title,
    description,
    $$scope,
    slots
  ];
}
var GalleryImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { title: 4, description: 5 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GalleryImage",
      options,
      id: create_fragment14.name
    });
  }
  get title() {
    throw new Error("<GalleryImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<GalleryImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get description() {
    throw new Error("<GalleryImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set description(value) {
    throw new Error("<GalleryImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var GalleryImage_default = GalleryImage;
export {
  BodyChild_default as BodyChild,
  GalleryController_default as GalleryController,
  GalleryImage_default as GalleryImage,
  GalleryThumbnail_default as GalleryThumbnail,
  Lightbox_default as Lightbox,
  LightboxBody_default as LightboxBody,
  LightboxFooter_default as LightboxFooter,
  Gallery_default as LightboxGallery,
  LightboxHeader_default as LightboxHeader,
  LightboxThumbnail_default as LightboxThumbnail,
  Modal_default as Modal,
  ModalCover_default as ModalCover,
  NextImageButton_default as NextImageButton,
  PreviousImageButton_default as PreviousImageButton,
  i18n_default as i18n
};
//# sourceMappingURL=svelte-lightbox.js.map
